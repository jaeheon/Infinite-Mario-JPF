\documentclass[twocolumn]{article}

\usepackage{listings}

\title{JPF/APROP for Infinite Mario}
\author{Chris Lewis and Ben Samuel and Jaeheon Yi}
\begin{document}
\maketitle

\section{Introduction}
Java PathFinder (JPF) is a stateful software model checker developed at NASA AMES Research Center. 
It is a \emph{software model checker} because it systematically explores all paths and inputs directly for software;
it is \emph{stateful} because it saves the program state after every logical operation. 

Although JPF is known as a model checker, it is used more often as a systematic testing and analysis framework. 
Compared with simpler abstractions often used for hardware model checking, software is much more complex with potentially exponentially many more states;
this quality makes exhaustive verification a difficult goal to attain. 
However, the methodical manner in which JPF generates program runs makes it ideal for testing programs; 
this compares much more favorably than with ad-hoc testing, which typically may only explore a fraction of the total state space without ever reaching a failure state. 

JPF is also a powerful analysis framework; for example, one can implement data race and deadlock detection algorithms and have JPF run over different runs to find potentially disastrous program states. 

JPF is a mature system with many extensions; for example, the core JPF system has been combined with symbolic execution the Bandera model constructor to create a richer feature set for testing and verification. 
JPF has been used to find real errors in Remote Agent Spacecraft Controller, a mission critical software component that had previously deadlocked during operation in space. 
It has also been used to find a very subtle concurrency error in a real time operating system. 



\section{What We Tried}
JPF is distributed as a single core, \texttt{jpf-core}, with a series of sub-projects build on top of it. We were interested in \texttt{jpf-aprop}. All of the sub-projects that have been worked on include a series of example files, which appear to be used for pseudo-documentation in lieu of actual manuals or tutorials.

We created a plan to learn about JPF/aprop:
\begin{itemize}
	\item Download JPF from the Mercurial repository and build the core and relevant subsystems
	\item Install the Eclipse plugin for rapid development
	\item Verify that the examples function as expected
	\item Use JPF/aprop on a small video game called Infinite Mario
\end{itemize}

Downloading the repository and the Eclipse plugin went as well as could be hoped for; as can be expected from a small open-source research project, there were some quirks (such as building each project individually, and a few bugs in the Eclipse plugin).

\subsection{Verifying the examples}
The \texttt{jpf-aprop} package comes with some small examples that illustrate various functionality. A JPF/aprop example contains one Java file, and one file with configuration project-specific configuration parameters, commonly referred to as a JPF file. It is worth noting that it is not necessary to have a JPF file in order to run a project with the JPF JVM, as long as you specify the correct parameters on the command-line. However, the Eclipse plugin relies on JPF files in order to verify a program, and we have not encountered an example from the developers which have not utilized a JPF file. 

An example JPF file from the JPF/aprop project can be found in Figure \ref{listing:jpffile}, and a code extract from the Java file it operates on in Figure \ref{listing:nonnull}

\begin{figure}[tb]
    \lstset{language=,breaklines=true}
    \begin{lstlisting}
target = NonnullViolation

listener.autoload=\
  javax.annotation.Nonnull

listener.javax.annotation.Nonnull=.aprop.listener.NonnullChecker
    \end{lstlisting}
    \caption{A JPF file that registers the detection \texttt{@NonNull} violation. Here we see the target class to be tested, and a listener defined to listen for a specific annotation.}
    \label{listing:jpffile}
\end{figure}

\begin{figure}[tb]
    \lstset{language=java,breaklines=true}
    \begin{lstlisting}
@Nonnull String id;

NonnullViolation (){
  id = null
}

@Nonnull
Object giveMeSomeObject() {
  return null;
}

\end{lstlisting}
	\caption{A Java extract showing two violations of the @NonNull annotation. The first violation is the assignment of \texttt{id} to null, even though \texttt{id} must remain non-null. The second violation is the \texttt{giveMeSomeObject()} method, that returns null even though the annotation claims it won't.}
	    \label{listing:nonnull}
	\end{figure}

We were able to verify the examples correctly, with an assertion exception being thrown when the non-null annotations were violated. Of interest is that it is not the fact that an uncaught exception is thrown that causes JPF to complain of an error, it is that a listener, \texttt{gov.nasa.jpf.jvm.NoUncaughtExceptionsProperty}, is defined to throw an error when an uncaught exception is thrown. If you disable this listener, much of the JPF functionality is disabled (including this example), and JPF will report a verified error-free execution, even though it is not.

\section{What We Learned}

\section{Conclusion}

\end{document}
